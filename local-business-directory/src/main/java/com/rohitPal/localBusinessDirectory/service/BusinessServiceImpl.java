package com.rohitPal.localBusinessDirectory.service;
import com.rohitPal.localBusinessDirectory.dto.BusinessDto;
import com.rohitPal.localBusinessDirectory.dto.BusinessResponse;
import com.rohitPal.localBusinessDirectory.exception.BusinessAlreadyExistsException;
import com.rohitPal.localBusinessDirectory.exception.BusinessNotFoundException;
import com.rohitPal.localBusinessDirectory.exception.LocationNotFoundException;
import com.rohitPal.localBusinessDirectory.model.Business;
import com.rohitPal.localBusinessDirectory.repository.BusinessRepository;
import com.rohitPal.localBusinessDirectory.repository.projection.BusinessProjection;
import jakarta.transaction.Transactional;
import org.locationtech.jts.geom.Point;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.List;
@Service
public class BusinessServiceImpl implements BusinessService{

    private final BusinessRepository businessRepository;
    private  OpenStreetMapGeocodingService openStreetMapGeocodingService;


    @Autowired
    private BusinessServiceImpl(BusinessRepository businessRepository , OpenStreetMapGeocodingService openStreetMapGeocodingService ){
        this.businessRepository = businessRepository;
        this.openStreetMapGeocodingService = openStreetMapGeocodingService;

    }
    @Override
    @Transactional
    public BusinessResponse addBusiness(BusinessDto businessDto) {
        /*
        ---------------------------------------------------------------------------------------------
        here , I am going to making use of manual mapping because i want use Geocoding Service to get
        longitude and latitude from String address.
        (at first I had tried to do so )
        ---------------------------------------------------------------------------------------------
         */

        if(businessRepository.existsByEmail(businessDto.getEmail())){
            throw new BusinessAlreadyExistsException("Business already registered with this Email Id.");
        }
        Business business = new Business();
        business.setBusinessCategory(businessDto.getCategory());
        business.setBusinessWebsite(businessDto.getWebsite());
        business.setBusinessName(businessDto.getName());
        business.setContactNumber(businessDto.getContactNumber());
        business.setAddress(businessDto.getAddress());
        business.setEmail(businessDto.getEmail());

        String address = businessDto.getAddress();
        Point point = openStreetMapGeocodingService.getCoordinates(address).orElseThrow(
                ()->new LocationNotFoundException("Location not found ! please enter valid address ")
        );

        business.setLocation(point);
        /*
        ------------------------------------------------------------------------------------------------------
        We don't need to save it manually  , hibernate does it automatically (because id does dirty checking).
        ------------------------------------------------------------------------------------------------------
        In the above line I misunderstood the concept of dirty checking .
        Corrected : Hibernate does dirty checking only when it tracks the object ( from creation in database )
        here ,in the above example I am creating object in transient state ( which is not tracked by hibernate)
        so in this case it will not manage.
        ------------------------------------------------------------------------------------------------------
         */
       /*
       in the below I was doing a conceptual mistake , i was not collecting savedBusiness and was returning business object with
       the info from dto(input) , so when i was returning it . it would not be having id ( because id will be generated by database
       automatically.
       (in such scenarios always return the saved entity )
        */
       Business savedBusiness = businessRepository.save(business);

        return businessMapper(savedBusiness);
    }
    /*
    -------------------------------------------------------------------------------
    I know that in production we should return BusinessResponse , here I am making
    use of just to make sure that the right record got deleted from the database
    while testing api on postman .
    -------------------------------------------------------------------------------
     */

    @Override
    @Transactional
    public BusinessResponse deleteBusiness(Long id) {
        Business business = businessRepository.findById(id).orElseThrow(()->
                new BusinessNotFoundException("Business Never created :"));
         businessRepository.deleteById(id);
         return businessMapper(business);
    }

    @Override
    @Transactional
    public BusinessResponse updateBusinessPhoneNumber(Long id, String contactNumber) {
       Business businessToUpdate = businessRepository.findById(id).orElseThrow(() ->
               new BusinessNotFoundException("Could not update it , first register the business"));

       businessToUpdate.setContactNumber(contactNumber);
       Business updatedBusiness =  businessRepository.save(businessToUpdate);
       return businessMapper(updatedBusiness);
    }

    @Override
    @Transactional
    public BusinessResponse updateBusinessLocation(Long id, String address) {
        Business businessToUpdate = businessRepository.findById(id).orElseThrow(() ->
                new BusinessNotFoundException("Could not update it , first register the business"));
        Point point = openStreetMapGeocodingService.getCoordinates(address).orElseThrow(() ->
                new LocationNotFoundException("location not found for the selected address !!" +
                        "please check address once more"));

        businessToUpdate.setLocation(point);
        businessToUpdate.setAddress(address);
        Business updatedBusiness = businessRepository.save(businessToUpdate);

        return businessMapper(updatedBusiness);

    }

    @Override
    public Page<BusinessResponse> getAllBusiness(Pageable pageDetails ) {
        Page<Business> page = businessRepository.findAll(pageDetails);
        return page.map(this::businessMapper);
    }

    @Override
    public BusinessResponse getBusinessById(Long id) {
        Business business = businessRepository.findById(id).orElseThrow(()->
                new BusinessNotFoundException("Business does not exits"));
        return businessMapper(business);
    }


    @Override
    public List<BusinessResponse> getNearbyBusinessWithin(double longitude, double latitude, double radius) {
     List<BusinessProjection> nearbyBusiness =  businessRepository.
             findNearByBusiness(longitude , latitude , radius);
     BusinessResponse response = new BusinessResponse();
        return nearbyBusiness.stream().
             map(this::businessProjectionMapper).
             toList();

    }

    private BusinessResponse businessMapper(Business business){

        if(business==null){
            return null;
        }
        BusinessResponse response = new BusinessResponse();
        response.setAddress(business.getAddress());
        response.setBusinessName(business.getBusinessName());
        response.setBusinessId(business.getId());
        response.setCategory(business.getBusinessCategory());
        response.setContactNumber(business.getContactNumber());
        response.setWebsite(business.getBusinessWebsite());
        response.setEmail(business.getEmail());

        Point point = business.getLocation();
        if(point!=null) {
            double longitude = point.getX();
            double latitude = point.getY();
            response.setLongitude(longitude);
            response.setLatitude(latitude);
        }
        return response;
    }

    private BusinessResponse businessProjectionMapper(BusinessProjection businessProjection){
        Business business = businessProjection.getBusiness();
        double distance = businessProjection.getDistance();

        BusinessResponse businessResponse = businessMapper(business);
        businessResponse.setDistanceInKm(distance);
        return businessResponse;
    }

}
